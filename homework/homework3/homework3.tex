\documentclass{article}
\usepackage{enumerate}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{subfigure}
\usepackage{geometry}
\usepackage{caption}
\usepackage{indentfirst}
\geometry{left=3.0cm,right=3.0cm,top=3.0cm,bottom=4.0cm}
\renewcommand{\thesection}{Ex. \arabic{section} ---}
\renewcommand{\mod}{{\rm\ mod\ }}
\title{VE475 Homework 3}
\author{Liu Yihao 515370910207}
\date{}

\begin{document}
\maketitle

\section{Finite fields}
\begin{enumerate}
\item
The possible factors of $X^2+1$ in $F_3[X]$ are $X,X+1,X+2$ 
$$X(X+1)=X^2+X\neq X^2+1$$
$$X(X+2)=X^2+2X\neq X^2+1$$
$$(X+1)(X+2)=X^2+3X+2=X^2+2\neq X^2+1$$
$$X\cdot X=X^2\neq X^2+1$$
$$(X+1)(X+1)=X^2+2X+1\neq X^2+1$$
$$(X+2)(X+2)=X^2+4X+4=X^2+X+1\neq X^2+1$$
So $X^2+1$ is irreducible in $F_3[X]$
\item
According to the Proof on c2, Page 39, if $P(X)$ is irreducible and $A(X)$ is a polynomial in a finite field, there exists a polynomial $B(X)$ such that $$A(X)B(X)\equiv1\mod P(X)$$
Here let $P(X)=X^2+1$, $A(X)=1+2X$, then $B(X)$ is the multiplication inverse of $1+2X\mod X^2+1$.
\item
Applying the Extended Euclid Algorithm,
\begin{center}
\begin{tabular}{|c|c|c|c|c|}
\hline
& $q_i$ & $r_i$ & $s_i$ & $t_i$\\\hline
0 & & $2X+1$ & 1 & 0\\\hline
1 & & $X^2+1$ & 0 & 1\\\hline
2 & $(2X+1)\div(X^2+1)=0$ & $2X+1$ & $1$ & $0$\\\hline
3 & $(X^2+1)\div(2X+1)=2X$ & $X+1$ & $X$ & $1$\\\hline
4 & $(2X+1)\div(X+1)=2$ & $2$ & $X+1$ & $1$\\\hline
5 & $(X+1)\div2=2X$ & $1$ & $X^2+2X$ & $X+1$\\\hline
\end{tabular}
\end{center}
$$(1+2X)(X^2+2X)\equiv1\mod X^2+1$$
\end{enumerate}

\section{AES}
\begin{enumerate}
\item
\begin{enumerate}[(a)]
\item
\emph{InvShiftRows} cyclically shift to the right row $i$ by offset $i$, $0\leqslant i\leqslant3$.
\item
The inverse of \emph{AddRoundKey} is actually the same as itself, since if we xor a value by another value twice, it will keep not changed. We only need to reverse the order of round keys.
\item
The transformation matrix of \emph{MixColumns} is 
$$A=\begin{pmatrix}
00000010 & 00000011 & 00000001 & 00000001 \\
00000001 & 00000010 & 00000011 & 00000001 \\
00000001 & 00000001 & 00000010 & 00000011 \\
00000011 & 00000001 & 00000001 & 00000010 \\
\end{pmatrix}=\begin{pmatrix}
02 & 03 & 01 & 01 \\
01 & 02 & 03 & 01 \\
01 & 01 & 02 & 03 \\
03 & 01 & 01 & 02 \\
\end{pmatrix}$$
If the transformation matrix of \emph{InvMixColumns} is 
$$B=\begin{pmatrix}
00001110 & 00001011 & 00001101 & 00001001 \\
00001001 & 00001110 & 00001011 & 00001101 \\
00001101 & 00001001 & 00001110 & 00001011 \\
00001011 & 00001101 & 00001001 & 00001110 \\
\end{pmatrix}=\begin{pmatrix}
0E & 0B & 0D & 09 \\
09 & 0E & 0B & 0D \\
0D & 09 & 0E & 0B \\
0B & 0D & 09 & 0E \\
\end{pmatrix}$$

We can calculate $BA$ according to the definition of $GF(2^8)$.\\
For example (in hex form), in the first column, 
\begin{align*}
(0E\cdot02)\oplus(0B\cdot01)\oplus(0D\cdot01)\oplus(09\cdot03)&=01\\
(09\cdot02)\oplus(0E\cdot01)\oplus(0B\cdot01)\oplus(0D\cdot03)&=00\\
(0D\cdot02)\oplus(09\cdot01)\oplus(0E\cdot01)\oplus(0B\cdot03)&=00\\
(0B\cdot02)\oplus(0D\cdot01)\oplus(09\cdot01)\oplus(0E\cdot03)&=00
\end{align*}
The calculation of other three column is similar, thus we can get
$$BA=\begin{pmatrix}
01 & 00 & 00 & 00 \\
00 & 01 & 00 & 00 \\
00 & 00 & 01 & 00 \\
00 & 00 & 00 & 01 \\
\end{pmatrix}=\begin{pmatrix}
00000001 & 00000000 & 00000000 & 00000000 \\
00000000 & 00000001 & 00000000 & 00000000 \\
00000000 & 00000000 & 00000001 & 00000000 \\
00000000 & 00000000 & 00000000 & 00000001 \\
\end{pmatrix}=I$$
If the origin matrix is $S$, the mix-columned matrix is $AS$, then $$B(AS)=BA(S)=IS=S$$
\end{enumerate}
\item
First, we generate the round keys according to the key, then we apply \emph{AddRoundKey} with round key (40--43).\\[1mm]
Second, we apply nine turns of following four steps ($i$ is the turn number): \emph{InvShiftRows}, \emph{InvSubBytes}, \emph{AddRoundKey} with round key ($40-4*i$--$43-4*i$) and \emph{InvMixColumns}.\\[1mm]
At last, we apply \emph{InvShiftRows}, \emph{InvSubBytes} and \emph{AddRoundKey} with round key (0--3).
\item
Since \emph{InvShiftRows} doesn't change the value of any cell, and \emph{InvSubBytes} only substitutes the value of each cell according to a table, the order of applying them doesn't influence the result. So they can be applied on reverse order.
\item
\begin{enumerate}[(a)]
\item
Since \emph{InvMixColumns} and \emph{AddRoundKey} affect the value of each column based on completely different theorems, the reverse order may cause a different result.
\item
$$[(m_{i,j})(a_{i,j})]\oplus(k_{i,j})$$
\item
$$(a_{i,j})=(m_{i,j})^{-1}[(e_{i,j})\oplus(k_{i,j})]=[(m_{i,j})^{-1}(e_{i,j})]\oplus[(m_{i,j})^{-1}(k_{i,j})]$$
So the inverse operation is given by
$$(e_{i,j})\longrightarrow(m_{i,j})^{-1}(e_{i,j})\oplus(m_{i,j})^{-1}(k_{i,j})$$
\item
\emph{InvAddRoundKey} first apply \emph{InvMixColumns} to the key, then apply \emph{AddRoundKey} to the data with the inv-mix-columned key.
\end{enumerate}
\item
First, we generate the round keys according to the key, then we apply \emph{AddRoundKey} with round key (40--43).\\[1mm]
Second, we apply nine turns of following four steps ($i$ is the turn number): \emph{InvSubBytes}, \emph{InvShiftRows}, \emph{InvMixColumns} and \emph{InvAddRoundKey} with round key ($40-4*i$--$43-4*i$).\\[1mm]
At last, we apply \emph{InvSubBytes}, \emph{InvShiftRows} and \emph{AddRoundKey} with round key (0--3).
\item The advantage of this strategy is that we only need to implement the four inverse transformations and apply them in the same order as the encryption process. Thus the encryption and decryption process can be unified and written only once.
\end{enumerate}

\section{DES}
\begin{enumerate}
\item
In DES, the length of plaintext is 64 bits, and the length of key is 56 bits.\\[1mm]
First, the plaintext is transformed according to the following table:
\begin{center}
\begin{tabular}{c|cccccccc}
& 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 \\
\hline
1 & 58 & 50 & 42 & 34 & 26 & 18 & 10 & 2 \\
2 & 60 & 52 & 44 & 36 & 28 & 20 & 12 & 4 \\
3 & 62 & 54 & 46 & 38 & 30 & 22 & 14 & 6 \\
4 & 64 & 56 & 48 & 40 & 32 & 24 & 16 & 8 \\
5 & 57 & 49 & 41 & 33 & 25 & 17 &  9 & 1 \\
6 & 59 & 51 & 43 & 35 & 27 & 19 & 11 & 3 \\
7 & 61 & 53 & 45 & 37 & 29 & 21 & 13 & 5 \\
8 & 63 & 55 & 47 & 39 & 31 & 23 & 15 & 7 \\
\end{tabular}
\end{center}

Then the transformed plaintext is divided into two parts of 32 bits, and we apply Feistel Network 16 times. Each time we use a generated key, which will be introduced later.\\[1mm]
At last, we apply a reverse transformation, which is shown in the following table.
\begin{center}
\begin{tabular}{c|cccccccc}
& 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 \\
\hline
1 & 40 & 8 & 48 & 16 & 56 & 24 & 64 & 32 \\
2 & 39 & 7 & 47 & 15 & 55 & 23 & 63 & 31 \\
3 & 38 & 6 & 46 & 14 & 54 & 22 & 62 & 30 \\
4 & 37 & 5 & 45 & 13 & 53 & 21 & 61 & 29 \\
5 & 36 & 4 & 44 & 12 & 52 & 20 & 60 & 28 \\
6 & 35 & 3 & 43 & 11 & 51 & 19 & 59 & 27 \\
7 & 34 & 2 & 42 & 10 & 50 & 18 & 58 & 26 \\
8 & 33 & 1 & 41 &  9 & 49 & 17 & 57 & 25 \\
\end{tabular}
\end{center}



\end{enumerate}

\section{Programming}
In the ex4 folder, with a README file inside it.

\end{document}
